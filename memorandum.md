# fmul

- s, tが正規化されているかどうか調べる
非正規化されていれば何桁落ちるかも調べる

- man_s, man_tの先頭1bitを補完する
正規化数ならば1, 非正規化数ならば0で

- 掛け算する
やるだけ

- 正規化する
落ちている桁数分だけずらして調べる必要がある
(正規化されていれば0桁落とす)
ずらした数に対してcarryを見て採用する23bitを決める
(非正規化数ではcarry=0である)

- 丸める
加算と同じように調べよう
ここもcarryによって場合分けが生える

- 出力する
やるだけ

# finv

Aの逆数
- 2次収束
NOTE: 逆数の2倍を求めるので更新式が若干変わった
x_{n+1} = 2 * x_n - A * x_n^2 / 2 
有効桁が2倍ずつ増えていく→5,6回?

# NOTE:
(-1)^s 2^e m -> (-1)^s 2^(-e-1) (2/m)

1 < m < 2 -> 1 < 2/m < 2
8桁->8桁でmapを作成する
48桁で計算して上位をとる(適切に丸める)
するとnewton法を回すのが2回程度ですむ