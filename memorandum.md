# fmul

- s, tが正規化されているかどうか調べる
非正規化されていれば何桁落ちるかも調べる

- man_s, man_tの先頭1bitを補完する
正規化数ならば1, 非正規化数ならば0で

- 掛け算する
やるだけ

- 正規化する
落ちている桁数分だけずらして調べる必要がある
(正規化されていれば0桁落とす)
ずらした数に対してcarryを見て採用する23bitを決める
(非正規化数ではcarry=0である)

- 丸める
加算と同じように調べよう
ここもcarryによって場合分けが生える

- 出力する
やるだけ

# finv

Aの逆数
- 2次収束
x_{n+1} = 2 * x_n - A * x_n^2
有効桁が2倍ずつ増えていく→5,6回?
